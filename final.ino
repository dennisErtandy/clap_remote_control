#include <IRremote.h>

const unsigned int  rawDataOn[] PROGMEM = {604, 17908, 3032, 8940, 548, 448, 552, 1464, 528, 452, 548, 468, 528, 472, 500, 496, 500, 496, 500, 500, 524, 472, 528, 1468, 552, 444, 556, 440, 556, 1440, 556, 440, 556, 444, 552, 1444, 552, 1448, 544, 1472, 524, 1468, 500, 1496, 496, 500, 524, 476, 524, 472, 552, 444, 556, 440, 556, 444, 552, 444, 556, 440, 556, 444, 552, 448, 552, 448, 548, 448, 548, 472, 528, 452, 544, 472, 524, 472, 500, 496, 500, 500, 496, 500, 500, 496, 528, 472, 552, 444, 556, 440, 556, 444, 552, 444, 556, 440, 556, 444, 552, 448, 552, 444, 552, 448, 548, 472, 524, 456, 544, 1468, 500, 1496, 496, 1496, 524, 1472, 552, 2952, 3032, 8936, 556, 1440, 552, 444, 556, 440, 556, 444, 552, 448, 548, 452, 548, 448, 548, 452, 548, 468, 528, 1468, 500, 496, 500, 500, 496, 1496, 524, 476, 552, 1440, 556, 1440, 552, 1444, 552, 1440, 556, 1444, 548, 1448, 548, 472, 528, 468, 528, 468, 500, 500, 500, 496, 500, 496, 500, 500, 524, 472, 528, 468, 556, 444, 552, 444, 556, 444, 552, 444, 552, 444, 556, 444, 552, 448, 548, 448, 548, 452, 548, 472, 524, 472, 528, 468, 500, 500, 500, 496, 500, 496, 500, 500, 524, 472, 556, 440, 556, 444, 552, 444, 556, 444, 552, 444, 552, 444, 556, 444, 552, 448, 548, 448, 552, 448, 520, 2980, 3004, 8988, 528, 1468, 500, 496, 500, 500, 496, 500, 524, 472, 528, 472, 552, 444, 556, 440, 556, 444, 552, 1440, 556, 444, 552, 448, 552, 448, 548, 448, 548, 1468, 528, 1468, 528, 472, 500, 1492, 500, 1496, 524, 1468, 556, 1440, 556, 1440, 552, 1440, 556, 1444, 552, 1444, 548, 452, 548, 468, 528, 472, 524, 1468, 500, 1496, 500, 1492, 528, 472, 528, 468, 556, 444, 552, 444, 556, 440, 556, 1440, 556, 444, 552, 1444, 552, 448, 548, 1464, 532, 468, 528, 472, 500, 1492, 500, 1496, 500, 496, 528, 472, 552, 444, 556, 440, 556, 444, 552, 444, 556, 440, 556, 1444, 552, 1444, 548, 1468, 528, 1468, 524}; 
const unsigned int  rawDataOff[] PROGMEM = {608, 17848, 3032, 8936, 556, 444, 552, 1464, 528, 472, 528, 468, 528, 472, 500, 496, 500, 496, 500, 500, 496, 500, 524, 1472, 552, 444, 556, 440, 556, 1440, 556, 1440, 552, 448, 552, 1444, 548, 1468, 528, 1468, 524, 1472, 500, 1492, 500, 496, 504, 496, 524, 472, 556, 444, 552, 444, 552, 444, 556, 440, 556, 444, 552, 444, 560, 440, 552, 448, 548, 448, 552, 468, 528, 468, 532, 468, 528, 468, 504, 496, 496, 500, 500, 496, 524, 476, 524, 472, 556, 444, 552, 444, 552, 444, 556, 440, 556, 444, 552, 444, 556, 444, 552, 448, 548, 448, 548, 452, 548, 468, 528, 472, 528, 468, 504, 1492, 500, 1496, 552, 2948, 3036, 8936, 552, 1440, 556, 444, 552, 444, 556, 440, 532, 468, 528, 472, 552, 444, 552, 448, 524, 496, 504, 1492, 524, 472, 500, 496, 500, 1496, 500, 496, 524, 1472, 552, 1444, 552, 1440, 532, 1464, 528, 1468, 552, 1444, 552, 448, 524, 492, 528, 472, 504, 492, 500, 500, 500, 496, 500, 500, 496, 500, 524, 472, 528, 472, 552, 444, 552, 444, 556, 440, 556, 444, 528, 468, 532, 468, 528, 472, 524, 472, 552, 448, 548, 468, 528, 472, 528, 472, 500, 496, 500, 496, 500, 496, 524, 476, 524, 472, 552, 448, 552, 444, 532, 464, 532, 468, 528, 468, 528, 468, 556, 444, 552, 448, 552, 444, 524, 2980, 3008, 8984, 528, 1468, 524, 472, 500, 500, 496, 500, 500, 496, 524, 476, 524, 472, 552, 448, 528, 468, 552, 1440, 532, 468, 552, 444, 552, 448, 552, 1444, 528, 1488, 504, 1492, 528, 472, 524, 1468, 500, 1496, 524, 1472, 528, 1464, 532, 1464, 528, 1464, 532, 1468, 532, 1464, 548, 452, 548, 468, 528, 472, 528, 1464, 504, 1492, 500, 1496, 524, 472, 528, 472, 528, 468, 552, 444, 532, 468, 552, 1440, 532, 468, 552, 1444, 528, 468, 528, 1492, 528, 468, 528, 472, 500, 1492, 500, 1496, 500, 500, 520, 476, 528, 468, 552, 448, 528, 468, 552, 444, 552, 448, 528, 468, 552, 444, 532, 1468, 524, 1472, 520};

void setup() {
  // put your setup code here, to run once:
Serial.begin(9600);
}
 IRsend irsend;
void loop() {
  // put your main code here, to run repeatedly:

int state_ptr;
int stage = 0;

int k = 0 ;
if (stage == 0 && analogRead(A0)>1000)
{
  delay(50);
  k=0;
  for(k=0;k<10;k++)
  {
    delay (10);
    if(analogRead(A0)<1000)
    {
        
       stage++;

       break;
     }
   }
   

delay(150);

k=0;
for(k=0;k<250;k++)
  {
    delay(2);
    if (stage == 1 && analogRead(A0)>1000)
      {
        k=0;
        for(k =0;k<10;k++)
        {
          delay (10);
          if(analogRead(A0)<1000)
          {
            stage++;          
         
            transmit(&state_ptr);
            break;
          }
          
        }
      }
  }

}

}
int transmit(int *state_ptr)
{ 
  int khz = 38;
  
  unsigned int buf[349];
  
 if (*state_ptr == 0)
 {

  memcpy_P (buf, rawDataOn, sizeof(rawDataOn));

  
  irsend.sendRaw(buf, sizeof(buf) / sizeof(buf[0]), khz);
  *state_ptr =+ 1;
  return 0;
 }
 if(*state_ptr==1)
 {
 
memcpy_P (buf, rawDataOff, sizeof(rawDataOn));

  
 irsend.sendRaw(buf, sizeof(buf) / sizeof(buf[0]), khz);
 *state_ptr-=1 ;
 return 0 ;
 }

   
 else
 {
  *state_ptr = 0;
 }
  
}
